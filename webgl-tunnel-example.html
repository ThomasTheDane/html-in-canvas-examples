<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>WebGL Tunnel UI Example</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: white;
      font-family: sans-serif;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
    }

    .ui-screen {
      width: 600px;
      height: 400px;
      position: absolute;
      transform-origin: top left;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
      gap: 15px;
    }

    /* Theme 0: Cyberpunk */
    .theme-0 {
      background: #0f0f1a;
      border: 2px solid #0ff;
      color: #f0f;
      font-family: monospace;
      box-shadow: 0 0 10px #0ff;
    }

    .theme-0 button {
      background: transparent;
      border: 1px solid #f0f;
      color: #0ff;
      padding: 5px;
    }

    /* Theme 1: Retro Wave */
    .theme-1 {
      background: linear-gradient(to bottom, #2b00ff, #e900ff);
      border: 5px solid yellow;
      color: white;
      font-family: sans-serif;
      font-style: italic;
    }

    /* Theme 2: Glassmorphism */
    .theme-2 {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      color: #fff;
      border-radius: 20px;
    }

    /* Theme 3: Neumorphism */
    .theme-3 {
      background: #e0e5ec;
      color: #333;
      border-radius: 20px;
      box-shadow: 9px 9px 16px rgb(163, 177, 198, 0.6), -9px -9px 16px rgba(255, 255, 255, 0.5);
    }

    /* Theme 4: Material */
    .theme-4 {
      background: #fff;
      color: #000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      font-family: Roboto, sans-serif;
      border-top: 5px solid #6200ea;
    }

    /* Theme 5: Terminal */
    .theme-5 {
      background: #000;
      color: #0f0;
      font-family: "Courier New", Courier, monospace;
      border: 2px solid #0f0;
    }

    /* Theme 6: Win95 */
    .theme-6 {
      background: #c0c0c0;
      color: #000;
      border: 2px solid;
      border-color: #fff #808080 #808080 #fff;
      font-family: "MS Sans Serif", sans-serif;
    }

    /* Theme 7: Minimal */
    .theme-7 {
      background: #fff;
      color: #000;
      border: 1px solid #000;
      font-family: Helvetica, sans-serif;
    }

    /* Theme 8: Comic */
    .theme-8 {
      background: #ffeb3b;
      color: #000;
      border: 4px solid #000;
      border-radius: 10px;
      font-family: "Comic Sans MS", cursive;
      box-shadow: 5px 5px 0 #000;
    }

    /* Theme 9: Wood */
    .theme-9 {
      background: #8b5a2b;
      color: #fff;
      border: 5px solid #5c3a21;
      font-family: Georgia, serif;
      border-radius: 5px;
    }

    /* Theme 10: Space */
    .theme-10 {
      background: radial-gradient(circle, #20002c 0%, #000 100%);
      color: #fff;
      border: 1px solid #fff;
      box-shadow: inset 0 0 20px #fff;
    }

    /* Theme 11: Pastel */
    .theme-11 {
      background: #ffd1dc;
      color: #777;
      border: 3px dashed #ffb6c1;
      border-radius: 20px;
      font-family: "Trebuchet MS", sans-serif;
    }

    /* Theme 12: Industrial */
    .theme-12 {
      background: #4a4a4a;
      color: #ffa500;
      border: 5px solid #222;
      font-family: Impact, "Arial Black", sans-serif;
    }

    /* Theme 13: High Contrast */
    .theme-13 {
      background: #000;
      color: #ff0;
      border: 5px solid #ff0;
      font-size: 1.2em;
      font-weight: bold;
    }

    /* Theme 14: Candy */
    .theme-14 {
      background: linear-gradient(45deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
      color: #d00;
      border: 4px solid #fff;
      border-radius: 30px;
    }

    /* Theme 15: Hologram */
    .theme-15 {
      background: rgba(0, 255, 255, 0.1);
      color: #0ff;
      border: 1px solid #0ff;
      text-shadow: 0 0 5px #0ff;
      background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.1) 2px, rgba(0, 255, 255, 0.1) 4px);
    }

    /* Theme 16: Arcade */
    .theme-16 {
      background: #000;
      color: red;
      border: 4px dotted yellow;
      text-align: center;
      text-transform: uppercase;
    }

    /* Theme 17: Medical */
    .theme-17 {
      background: #e0f7fa;
      color: #006064;
      border: 2px solid #00bcd4;
      font-family: Arial, sans-serif;
      border-radius: 8px;
    }

    /* Theme 18: Luxury */
    .theme-18 {
      background: #1a1a1a;
      color: #d4af37;
      border: 2px solid #d4af37;
      font-family: "Times New Roman", Times, serif;
    }

    /* Theme 19: Chalkboard */
    .theme-19 {
      background: #2f4f4f;
      color: #fff;
      border: 10px solid #8b4513;
      font-family: "Marker Felt", fantasy;
    }

    .ui-screen h2 {
      margin: 0;
    }

    .ui-screen .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex: 1;
      justify-content: space-around;
    }
  </style>
</head>

<body>

  <div id="info">
    Arrow Keys / WASD: Move<br>
    Mouse Drag: Look Around<br>
  </div>

  <canvas id="gl-canvas" layoutsubtree="true"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

  <script>
    // 1. Generate UI Screens
    const canvas = document.getElementById('gl-canvas');
    const SCREEN_COUNT = 20;

    const adjectives = ["Quantum", "Neural", "Cyber", "Astro", "Turbo", "Hyper", "Neo", "Syntethic", "Retro", "Cosmic"];
    const nouns = ["Matrix", "Network", "Engine", "Algorithm", "Protocol", "System", "Drive", "Interface", "Module", "Core"];
    const actions = ["Initialize", "Calibrate", "Synchronize", "Deploy", "Execute", "Bypass", "Overclock", "Reboot", "Analyze", "Process"];

    function rndText(words, count) {
      let res = [];
      for (let i = 0; i < count; i++) res.push(words[Math.floor(Math.random() * words.length)]);
      return res.join(" ");
    }

    const elementsData = [
      () => `<p style="font-size: 0.9em; line-height: 1.4; opacity: 0.8;"><b>Log:</b> ${rndText(actions, 1)} ${rndText(adjectives, 1)} ${rndText(nouns, 1)}... Status: <span style="color: ${Math.random() > 0.5 ? '#0f0' : '#f00'}">${Math.random() > 0.5 ? 'ONLINE' : 'ERROR'}</span>. Additional data: ${Math.random().toString(36).substring(2, 10)}.</p>`,
      () => `<label style="display:flex; align-items:center; gap:10px;"><b>Volume</b> <input type="range" min="0" max="100" value="${Math.floor(Math.random() * 100)}" style="flex-grow:1;"></label>`,
      () => `<label style="display:flex; align-items:center; gap:10px;"><b>Intensity</b> <input type="range" min="0" max="100" value="${Math.floor(Math.random() * 100)}" style="flex-grow:1;"></label>`,
      () => `<label style="display:block; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 4px;"><input type="checkbox" ${Math.random() > 0.5 ? 'checked' : ''}> Enable ${rndText(adjectives, 1)} ${rndText(nouns, 1)}</label>`,
      () => `<label style="display:block; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 4px;"><input type="checkbox" ${Math.random() > 0.5 ? 'checked' : ''}> Override ${rndText(nouns, 1)}</label>`,
      () => `<div><b>Input ${rndText(nouns, 1).substring(0, 3).toUpperCase()}: </b><input type="text" value="${Math.random().toString(16).substring(2, 8).toUpperCase()}" style="padding:4px;width:100px;background:rgba(255,255,255,0.8);color:#000;border:none;"></div>`,
      () => `<div><b>Target: </b><input type="text" placeholder="Enter coords..." style="padding:4px;width:120px;background:rgba(255,255,255,0.8);color:#000;border:none;"></div>`,
      () => `<button style="padding: 10px; font-weight: bold; cursor: pointer; border: none; border-radius: 4px; background: rgba(255,255,255,0.2); transition: 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.4)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" onclick="alert('${rndText(actions, 1)}ing...')">${rndText(actions, 1)} Sequence</button>`,
      () => `<div style="display:flex; justify-content:space-between; align-items:center; border: 1px solid currentColor; padding: 5px;"><span style="font-size: 0.8em; text-transform:uppercase;">${rndText(nouns, 1)}</span> <b>${Math.floor(Math.random() * 9999)}</b></div>`,
      () => `<label style="display:flex; align-items:center; gap:5px;"><b>Mode:</b> <select style="padding: 2px; background:rgba(255,255,255,0.9);"><option>Auto</option><option>Manual</option><option>Bypass</option></select></label>`,
      () => `<div style="display: flex; gap: 5px;">${[1, 2, 3, 4].map(() => `<div style="flex:1; height: 10px; background: ${Math.random() > 0.3 ? 'currentColor' : 'transparent'}; opacity: 0.5;"></div>`).join('')}</div>`,
      () => `<label><b>Color:</b> <input type="color" value="#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}"></label>`
    ];

    for (let i = 0; i < SCREEN_COUNT; i++) {
      const screen = document.createElement('div');
      screen.className = `ui-screen theme-${i % 20}`; // loop themes if we go over 20
      screen.id = `ui-${i}`;

      // Generate Random Content
      let contentHtml = `<h2>${rndText(adjectives, 1)} ${rndText(nouns, 1)} [${i + 1}]</h2>`;
      contentHtml += `<div class="controls">`;

      const numElements = Math.floor(Math.random() * 4) + 3; // 3 to 6 elements
      // Shuffle elements array to pick randomly
      const shuffledElements = [...elementsData].sort(() => 0.5 - Math.random());

      for (let j = 0; j < numElements; j++) {
        contentHtml += shuffledElements[j]();
      }

      contentHtml += `</div>`;
      screen.innerHTML = contentHtml;
      canvas.appendChild(screen);
    }

    // 2. WebGL Setup
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      alert('WebGL2 not supported');
    }

    const vsSource = `#version 300 es
  layout(location = 0) in vec4 aPosition;
  layout(location = 1) in vec2 aTexCoord;

  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  out vec2 vTexCoord;

  void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aPosition;
    vTexCoord = aTexCoord;
  }
  `;

    const fsSource = `#version 300 es
  precision highp float;

  in vec2 vTexCoord;
  uniform sampler2D uSampler;
  uniform vec4 uColor;
  uniform bool uUseTexture;

  out vec4 fragColor;

  void main() {
    if (uUseTexture) {
      fragColor = texture(uSampler, vTexCoord);
    } else {
      fragColor = uColor;
    }
  }
  `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    const programInfo = {
      program: program,
      attribs: {
        position: gl.getAttribLocation(program, 'aPosition'),
        texCoord: gl.getAttribLocation(program, 'aTexCoord'),
      },
      uniforms: {
        projection: gl.getUniformLocation(program, 'uProjectionMatrix'),
        modelView: gl.getUniformLocation(program, 'uModelViewMatrix'),
        sampler: gl.getUniformLocation(program, 'uSampler'),
        color: gl.getUniformLocation(program, 'uColor'),
        useTexture: gl.getUniformLocation(program, 'uUseTexture'),
      },
    };

    // Quad Buffer (Size 1x1, centered)
    const positions = new Float32Array([
      -0.5, 0.5, 0.0,
      0.5, 0.5, 0.0,
      -0.5, -0.5, 0.0,
      0.5, -0.5, 0.0,
    ]);

    const texCoords = new Float32Array([
      0.0, 0.0,
      1.0, 0.0,
      0.0, 1.0,
      1.0, 1.0,
    ]);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(programInfo.attribs.position);
    gl.vertexAttribPointer(programInfo.attribs.position, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.enableVertexAttribArray(programInfo.attribs.texCoord);
    gl.vertexAttribPointer(programInfo.attribs.texCoord, 2, gl.FLOAT, false, 0, 0);

    // Setup Textures for 20 UI Screens
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    const uiElements = [];
    for (let i = 0; i < SCREEN_COUNT; i++) {
      const el = document.getElementById(`ui-${i}`);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 600, 400, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

      // Calculate wall position
      // Side: even = left (-X), odd = right (+X)
      const side = (i % 2 === 0) ? -1 : 1;
      // Z spacing: 10 units apart. 2 screens per Z level.
      const zIndex = Math.floor(i / 2);
      const zPos = -10 - (zIndex * 10);

      uiElements.push({
        element: el,
        texture: texture,
        position: [side * 4, 0, zPos],
        rotation: [0, (side === -1) ? Math.PI / 2 : -Math.PI / 2, 0], // face inwards
        scale: [6, 4, 1] // ratio roughly 600x400
      });
    }

    // Input Handling
    const camera = {
      position: vec3.fromValues(0, 0, 5),
      rotation: vec3.fromValues(0, 0, 0) // Pitch, Yaw, Roll
    };

    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    window.addEventListener('mousedown', (e) => {
      if (e.target === canvas) {
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;

        camera.rotation[1] += deltaX * 0.0025; // Yaw
        camera.rotation[0] += deltaY * 0.0025; // Pitch

        // Limit pitch
        camera.rotation[0] = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, camera.rotation[0]));

        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
    });

    // Render Loop
    let lastTime = 0;
    function render(time) {
      time *= 0.001;
      const deltaTime = time - lastTime;
      lastTime = time;

      // Movement (Arrow Keys / WASD)
      const speed = 10.0 * deltaTime;
      const fwd = vec3.fromValues(-Math.sin(camera.rotation[1]), 0, -Math.cos(camera.rotation[1]));
      const right = vec3.fromValues(Math.cos(camera.rotation[1]), 0, -Math.sin(camera.rotation[1]));

      if (keys['ArrowUp'] || keys['KeyW']) {
        camera.position[0] += fwd[0] * speed;
        camera.position[2] += fwd[2] * speed;
      }
      if (keys['ArrowDown'] || keys['KeyS']) {
        camera.position[0] -= fwd[0] * speed;
        camera.position[2] -= fwd[2] * speed;
      }
      if (keys['ArrowLeft'] || keys['KeyA']) {
        camera.position[0] -= right[0] * speed;
        camera.position[2] -= right[2] * speed;
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        camera.position[0] += right[0] * speed;
        camera.position[2] += right[2] * speed;
      }

      // Resize
      if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      gl.clearColor(0.05, 0.05, 0.05, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      // Matrices
      const projectionMatrix = mat4.create();
      mat4.perspective(projectionMatrix, 45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 500.0);

      const viewMatrix = mat4.create();
      mat4.rotateX(viewMatrix, viewMatrix, -camera.rotation[0]);
      mat4.rotateY(viewMatrix, viewMatrix, -camera.rotation[1]);
      mat4.translate(viewMatrix, viewMatrix, vec3.negate(vec3.create(), camera.position));

      gl.useProgram(programInfo.program);
      gl.uniformMatrix4fv(programInfo.uniforms.projection, false, projectionMatrix);
      gl.bindVertexArray(vao);

      // Draw Floor and Ceiling (Tunnel)
      const floorMatrix = mat4.clone(viewMatrix);
      mat4.translate(floorMatrix, floorMatrix, [0, -3, -50]);
      mat4.rotateX(floorMatrix, floorMatrix, -Math.PI / 2);
      mat4.scale(floorMatrix, floorMatrix, [10, 200, 1]);
      gl.uniformMatrix4fv(programInfo.uniforms.modelView, false, floorMatrix);
      gl.uniform1i(programInfo.uniforms.useTexture, 0);
      gl.uniform4f(programInfo.uniforms.color, 0.1, 0.1, 0.15, 1.0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      const ceilingMatrix = mat4.clone(viewMatrix);
      mat4.translate(ceilingMatrix, ceilingMatrix, [0, 3, -50]);
      mat4.rotateX(ceilingMatrix, ceilingMatrix, Math.PI / 2);
      mat4.scale(ceilingMatrix, ceilingMatrix, [10, 200, 1]);
      gl.uniformMatrix4fv(programInfo.uniforms.modelView, false, ceilingMatrix);
      gl.uniform4f(programInfo.uniforms.color, 0.05, 0.05, 0.05, 1.0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      // Draw UI Screens
      for (let i = 0; i < uiElements.length; i++) {
        const item = uiElements[i];

        // Model Matrix
        const modelMatrix = mat4.create();
        mat4.translate(modelMatrix, modelMatrix, item.position);
        mat4.rotateY(modelMatrix, modelMatrix, item.rotation[1]);
        mat4.scale(modelMatrix, modelMatrix, item.scale);

        const modelViewMatrix = mat4.create();
        mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);

        // MVP Matrix
        const mvp = mat4.create();
        mat4.multiply(mvp, projectionMatrix, modelViewMatrix);

        if (canvas.getElementTransform) {
          // 1. Convert the MVP matrix (gl-matrix Float32Array) to a DOMMatrix
          const mvpDOM = new DOMMatrix(Array.from(mvp));

          const width = item.element.offsetWidth || 600;
          const height = item.element.offsetHeight || 400;

          // 2. Element CSS pixels -> WebGL Model Space
          const toGLModel = new DOMMatrix()
            .scale(1 / width, -1 / height, 1)
            .translate(-width / 2, -height / 2);

          // 3. WebGL Clip Space -> Canvas CSS pixels (Viewport Transform)
          const toCSSViewport = new DOMMatrix()
            .translate(canvas.width / 2, canvas.height / 2)
            .scale(canvas.width / 2, -canvas.height / 2, 1);

          // 4. Combine: Viewport * MVP * Model
          const finalTransform = toCSSViewport.multiply(mvpDOM).multiply(toGLModel);

          const transform = canvas.getElementTransform(item.element, finalTransform);
          if (transform) {
            item.element.style.transform = transform.toString();
          }
        }

        // Update Texture
        if (gl.texElementImage2D) {
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, item.texture);
          gl.texElementImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, item.element);
        }

        // Draw
        gl.uniformMatrix4fv(programInfo.uniforms.modelView, false, modelViewMatrix);
        gl.uniform1i(programInfo.uniforms.useTexture, 1);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, item.texture);
        gl.uniform1i(programInfo.uniforms.sampler, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>

</html>