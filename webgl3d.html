<!DOCTYPE html>
<head>
  <style>
    canvas { background: black; }
    div { width: 100px; height: 100px; background-color: rgba(0, 128, 0, 0.412); }
  </style>
</head>
<body>
  <canvas id=canvas width="200" height="200" layoutsubtree style="width: 200px; height: 200px;">
    <div id="child" contenteditable="true">hello<br>world<br>boo!</div>
  </canvas>

  <script>
    const observer = new ResizeObserver(([entry]) => {
      canvas.width = entry.devicePixelContentBoxSize[0].inlineSize;
      canvas.height = entry.devicePixelContentBoxSize[0].blockSize;

      const gl = canvas.getContext('webgl2');
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      // 1. Add uniform matrix to Vertex Shader
      const vsSrc = `#version 300 es
        in vec2 a_pos;
        in vec2 a_uv;
        uniform mat4 u_matrix;
        out vec2 v_uv;
        void main(){
          // Apply matrix multiplication
          gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
          v_uv = a_uv;
        }`;

      const fsSrc = `#version 300 es
        precision mediump float;
        in vec2 v_uv;
        uniform sampler2D u_tex;
        out vec4 fragColor;
        void main(){
          fragColor = texture(u_tex, v_uv);
        }`;

      const vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs, vsSrc);
      gl.compileShader(vs);
      const fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs, fsSrc);
      gl.compileShader(fs);

      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      gl.useProgram(prog);

      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      // Standard quad coordinates
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1,-1,0,0,  1,-1,1,0,  -1,1,0,1,
        -1,1,0,1,   1,-1,1,0,   1,1,1,1
      ]), gl.STATIC_DRAW);

      const posLoc = gl.getAttribLocation(prog, 'a_pos');
      const uvLoc = gl.getAttribLocation(prog, 'a_uv');
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(uvLoc);
      gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);

      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);

      // Initialize texture
      gl.texElementImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, child);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // Changed to Linear for better 3D look
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      gl.uniform1i(gl.getUniformLocation(prog, 'u_tex'), 0);

      // --- 3D MATRIX GENERATION ---

      // A standard perspective projection matrix (FOV ~60deg, Aspect 1.0, Near 0.1, Far 100)
      // Hardcoded for simplicity to avoid external math libraries.
      const projection = new DOMMatrix([
        1.73, 0, 0, 0,
        0, 1.73, 0, 0,
        0, 0, -1.002, -1,
        0, 0, -0.2, 0
      ]);

      // Use DOMMatrix to handle the Model transform (Rotate/Translate)
      const modelView = new DOMMatrix();
      modelView.translateSelf(0, 0, -3); // Move back into the screen
      modelView.rotateSelf(30, 45, 0);   // Rotate on X and Y axis

      // Multiply Projection * ModelView
      const finalMatrix = projection.multiply(modelView);

      // Upload to shader
      const matrixLoc = gl.getUniformLocation(prog, 'u_matrix');
      gl.uniformMatrix4fv(matrixLoc, false, finalMatrix.toFloat32Array());
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // --- COMPUTE CSS TRANSFORM ---

      // 1. Convert HTML Element pixels (0..100) to WebGL Model units (-1..1)
      //    - Translate (-50, -50) to center the element
      //    - Scale (2/100) to map 100px to 2 units
      //    - Flip Y (CSS Y is down, WebGL Y is up)
      const toGLModel = new DOMMatrix()
          .scale(2/100, -2/100, 1)
          .translate(-50, -50);

      // 2. Convert WebGL Clip Space (-1..1) to CSS Viewport pixels (0..200)
      //    - Translate (100, 100) to move center to canvas middle
      //    - Scale (100) to map 1 unit to 100px (half canvas size)
      //    - Flip Y (WebGL Y is up, CSS Y is down)
      const toCSSViewport = new DOMMatrix()
          .translate(100, 100)
          .scale(100, -100, 1);

      // 3. Combine: toCSS * finalMatrix * toGL
      //    This maps the element's pixels through the WebGL transform and back to screen pixels
      const cssTransform = toCSSViewport.multiply(finalMatrix).multiply(toGLModel);

      child.style.transform = canvas.getElementTransform(child, cssTransform).toString();
  });
  observer.observe(canvas, {box: 'device-pixel-content-box', fireOnEveryPaint: true});
  </script>
</body>